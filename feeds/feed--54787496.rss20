<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"><channel><description>notify.me technical and development blog</description><title>notify.me tech blog - INotification</title><generator>Tumblr (3.0; @inotification)</generator><link>http://techblog.notify.me/</link><item><title>Perl UTF-8 Hell And How To Find Your Way Out</title><description>&lt;p&gt;Character encoding are never easy to deal with.  Some trouble has to do with how your tools interpret the encoding.  For instance a unix terminal (in my case gterm) might try to “fix” an encoding because its thinks it knows what is best.  Or Data::Dumper might handle dumping high order utf8 in its own unique way.  On top of the when dealing with external data sources that vary in encoding and using cpan modules that all think they are doing the write thing makes it a challenging to debug and fix.&lt;/p&gt;
&lt;p&gt;Here’s my most recent experiences:&lt;/p&gt;
&lt;p&gt;Our project notify.me up till today could not display multi-byte utf8 character correctly (anything that was not ascii).  I setup a test blog on blogger and added the following text to the subject and body, 人写.&lt;/p&gt;
&lt;p&gt;When I used XML::Feed to display the subject and body I first see this in the logs&lt;/p&gt;
&lt;blockquote&gt;2008/11/12 22:38:29 DEBUG&gt; rss_processor.pl:413 main:: - Subject =&gt; 人写&lt;br/&gt;2008/11/12 22:38:29 DEBUG&gt; rss_processor.pl:414 main:: - Body =&gt; 人写&lt;br/&gt;
&lt;/blockquote&gt;
&lt;p&gt;Great..  However in the json object that gets created later I see this diversion&lt;/p&gt;
&lt;blockquote&gt;2008/11/12 22:38:29 DEBUG&gt; rss_processor.pl:450 main:: - … “Guid”:”00000004-0000-0055-0005-06491b5ae520”,&lt;br/&gt;“Subject”:”äººå”,&lt;br/&gt;“Content”:”人写”}&lt;br/&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hrmm  what is going on here?  I thought I checked earlier and saw that the strings were the same..  Well this is where we enter the realm of encoding madness.&lt;/p&gt;
&lt;p&gt;If I Data::Dumper both strings I get a subject as:&lt;/p&gt;
&lt;blockquote&gt;%foo = ( ‘Subject’ =&gt; ‘人写’  );&lt;/blockquote&gt;
&lt;p&gt;but a content as:&lt;/p&gt;
&lt;blockquote&gt;%bar = ( ‘Content’ =&gt; “\x{4eba}\x{5199}” );&lt;br/&gt;
&lt;/blockquote&gt;
&lt;p&gt;So the strings are different no doubt.  However looking at the Data::Dumper results it would seem that the subject is correct and the content is screwed.  However the opposite is true.  Data::Dumper escapes the unicode.  So what is going on with Subject.&lt;/p&gt;
&lt;p&gt;The first thing to do is get the actuall byte representations of characters.  To do this we use the ord (you can also use unpack).&lt;/p&gt;
&lt;blockquote&gt;$log-&gt;debug(“subject =&gt; ” . join(” “, map { ord($_ ) } split(//, $item-&gt;title)) );&lt;br/&gt;$log-&gt;debug(“content =&gt; ” . join(” “, map { ord($_ ) } split(//,  $item-&gt;content-&gt;body)) );&lt;br/&gt;
&lt;/blockquote&gt;
&lt;p&gt;what does this do?  We are breaking apart each character of the sting (in this case there are two) and then we are using ord to get the numeric 8-bit representation.  Then we join these ord values back up into one string.  To are amazement they are different values.&lt;/p&gt;
&lt;blockquote&gt;2008/11/12 22:38:29 DEBUG&gt; rss_processor.pl:416 main:: - subject =&gt; 228 186 186 229 134 153&lt;br/&gt;2008/11/12 22:38:29 DEBUG&gt; rss_processor.pl:417 main:: - content =&gt; 20154 20889&lt;br/&gt;
&lt;/blockquote&gt;
&lt;p&gt;The content string looks good, its a high order utf8 char encoding two chars long.  But what is going on with subject?  Does it really have 6 characters? No it does not because it prints out right.  WTF is going on.&lt;/p&gt;
&lt;p&gt;Well the jump you have to make is that subject was supposed to be proper utf8 but know one told perl so it thinks its latin1.  So how do we test this theory.&lt;/p&gt;
&lt;p&gt;We know we have two chars and 6 bytes so that means that there are three bytes per character.  Well that’s good because UTF8 can be 3 bytes long but it must match the 3-byte utf8 standard pattern (shown below).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1110-xxxx 10xx-xxxx 10xx-xxx&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So if we expand 228 186 186 into byte representations&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1110-0100 1011-1010 1011-1010&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And we can see the that bytes fit the utf8 pattern the first byte starts with 1110 and the second two start with 10&lt;/p&gt;
&lt;p&gt;So replacing the x’s above creates a 2 byte value&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0100-1110 1011-1010&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ok so that should be the utf8 encoding that the three byte represent.  So in hex that would represent&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;4 e b a&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So lets take the hex and convert it to decimal&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a (10) * (16^0) = 10&lt;/p&gt;
&lt;p&gt;b (11) * (16^1) = 176&lt;/p&gt;
&lt;p&gt;e (14) * (16^2) = 3,584&lt;/p&gt;
&lt;p&gt;4 (4)  * (16^3) = 16,384&lt;/p&gt;

&lt;p&gt;10 + 176 + 3,584 + 16,384 = 20154&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And HOLY crap that’s the content string number that ord spit out (up above).  So our theory is proven right.  But what the heck happened to get the subject string not being represented properly?  Well there seems to be a magic flag set for variables if the contents should be treated as utf8 and it looks like this flag did not get set for $subject.&lt;/p&gt;
&lt;p&gt;A little googling and you stumble upon this gem&lt;/p&gt;
&lt;p&gt;&lt;a href="http://search.cpan.org/~miyagawa/XML-Atom-0.29/lib/XML/Atom/Feed.pm#UNICODE_FLAGS"&gt;http://search.cpan.org/~miyagawa/XML-Atom-0.29/lib/XML/Atom/Feed.pm#UNICODE_FLAGS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and there is some theory to why it is this way &lt;a href="http://use.perl.org/~miyagawa/journal/30923"&gt;http://use.perl.org/~miyagawa/journal/30923&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and that’s why languages should start out supporting utf8 from the get go.&lt;/p&gt;
&lt;p&gt;You can set the magic utf8 flag by doing a&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;utf8::upgrade($string);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;of cource that did not work for me.  And I want into XML::Feed::Atom and set the flag to NOT strip utf8 from strings and I was back in business.&lt;/p&gt;
&lt;p&gt;You can also cheat with the map and use this nifty site&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ltg.ed.ac.uk/~richard/utf-8.cgi?input=%26%2320154%3B&amp;mode=char"&gt;http://www.ltg.ed.ac.uk/~richard/utf-8.cgi?input=%26%2320154%3B&amp;mode=char&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can see the latin1 reprsentation of the utf8 character was ‘äºº’ if you scroll to the top of the post you will see thats exactly what was in the json object.&lt;/p&gt;</description><link>http://techblog.notify.me/post/59407777</link><guid>http://techblog.notify.me/post/59407777</guid><pubDate>Wed, 12 Nov 2008 19:36:50 -0500</pubDate><category>utf8</category><category>latin1</category><category>bit</category><category>byte</category><category>representation</category><category>conversion</category></item><item><title>Interview on Highscalability</title><description>&lt;p&gt;Today &lt;a target="_blank" href="http://highscalability.com/"&gt;HighScalalability.com&lt;/a&gt; ran an &lt;a target="_blank" href="http://highscalability.com/notify-me-architecture-synchronicity-kills"&gt;interview&lt;/a&gt; with yours truly about our architecture. It kind of jumps the gun on the subjects that I’ve promised to cover, but I will cover them in a bit more depth. I’m still editing my next post which will primarily cover message queuing using &lt;a target="_blank" href="http://sourceforge.net/projects/simplemq"&gt;SimpleMQ&lt;/a&gt; (the production codebase of which is on sourceforge, I have just not gotten around to putting any kind of useful documentation there).&lt;/p&gt;
&lt;p&gt;In the meantime, a big thanks to HighScalability for article — I hope it gives a coherent overview of our architecture.&lt;/p&gt;</description><link>http://techblog.notify.me/post/56691161</link><guid>http://techblog.notify.me/post/56691161</guid><pubDate>Tue, 28 Oct 2008 00:31:33 -0400</pubDate></item><item><title>Great interview on concurrency directions</title><description>Channel 9 has an &lt;a target="_blank" href="http://channel9.msdn.com/posts/Charles/Anders-Hejlsberg-and-Guy-Steele-Concurrency-and-Language-Design/"&gt;interview&lt;/a&gt; from &lt;a target="_blank" href="http://jaoo.dk/"&gt;JAOO&lt;/a&gt; with &lt;a target="_blank" href="http://en.wikipedia.org/wiki/Anders_Hejlsberg"&gt;Anders Hejlsberg&lt;/a&gt; and &lt;a target="_blank" href="http://research.sun.com/people/mybio.php?uid=25706"&gt;Guy Steele&lt;/a&gt;, two of my favorite languages gurus. Lots of interesting perspectives on concurrency issues and imperative vs. functional solutions going forward. Guy Steele’s &lt;a target="_blank" href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html"&gt;Common Lisp&lt;/a&gt; reference was my bible back in grad school and Anders’ designs in C# have made it my current favorite language, especially the &lt;a target="_blank" href="http://msdn.microsoft.com/en-us/library/bb308966.aspx"&gt;3.0 bits&lt;/a&gt; giving a taste of functional in the otherwise imperative.</description><link>http://techblog.notify.me/post/53519598</link><guid>http://techblog.notify.me/post/53519598</guid><pubDate>Tue, 07 Oct 2008 18:02:06 -0400</pubDate><category>concurrency</category><category>C#</category><category>Lisp</category></item><item><title>Synchronicity kills</title><description>&lt;p&gt;I have quite a back log of technical material I want to post here, so let me just start with one of fundamentals of the tech behind &lt;a target="_blank" title="notify.me" href="http://notify.me"&gt;notify.me&lt;/a&gt;: &lt;i&gt;Asynchronous Programming&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;Behind the stories of internet service outages is almost always a bottleneck. And usually this bottleneck is due to synchronous access, i.e. some resource is requested and the requestor ties up more resources, waiting for a response. If the requested resource can’t be delivered in a timely manner, more and more requests pile up until the server can’t accept any new ones. Nobody gets what they want and you have an outage.&lt;/p&gt;
&lt;p&gt;Now, there’s plenty of efforts of increasing capacity by adding more horsepower and mitigating bottleneck resources by adding caching at various levels of the architecture. These techniques are proven and solve many problems. However, if the data was delivered asynchronously, instead of synchronously, apparent capacity is drastically increased, since resources aren’t tied up waiting. Because HTTP is a synchronous pull protocol and the internet is basically plumbed by HTTP, the first step in to asynchronicity is usually polling. Instead of asking for a resource and then holding the line until the demand is met, ajax (when talking browser as a client) or simply repeated calls (when the client is another service) keep asking &lt;i&gt;“you got my data?”&lt;/i&gt; and little bit later &lt;i&gt;“how about now?”&lt;/i&gt; and so on. As long as it’s cheap to say &lt;i&gt;no&lt;/i&gt;, polling reduces bottlenecks.&lt;/p&gt;
&lt;p&gt;Ideally, the conversation should follow a pattern of &lt;i&gt;“tell me when my data is ready”. &lt;/i&gt;In the browser scenario this isn’t strictly possible, although techniques such as &lt;a href="http://en.wikipedia.org/wiki/Comet_(programming)"&gt;comet&lt;/a&gt;, are repurposing HTTP to do just that even it it does in fact hold the line. However, holding a &lt;a target="_blank" href="http://meteorserver.org/"&gt;couple of thousand sockets&lt;/a&gt; open from a simple socket server is still a much better option than doing the same against the webserver.&lt;/p&gt;
&lt;p&gt;But I digress, because the inner workings of notify.me only touch web pages in small ways. While we will be looking at implementing some version of Comet on the site itself, our greater concern is our message traffic. And here we can easily use asynchronous methods to avoid having resource scarcity turn into resource overload. Breaking synchronous operations into asynchronous operations by separating request and response into separate message passing actions, stops the resource overload. Instead of a system going down from too many parallel requests, it can works its way through a backlog of requests as fast as it can. And in most cases the request/response cycles are so fast that they appear like a linear sequence of events.&lt;/p&gt;
&lt;p&gt;In the the next couple of posts, I will go over the three different types of message passing systems we use:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Store-and-forward message queueing using &lt;a target="_blank" href="http://sourceforge.net/projects/simpleMQ"&gt;simpleMQ&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;REST calls with REST callback URI registration&lt;/li&gt;
&lt;li&gt;Xmpp message bus using message stanzas as well as IQ based RPC&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I’ll discuss each in detail, including previews of our external REST and XMPP APIs, currently in internal testing.&lt;/p&gt;</description><link>http://techblog.notify.me/post/53013683</link><guid>http://techblog.notify.me/post/53013683</guid><pubDate>Sat, 04 Oct 2008 03:30:33 -0400</pubDate></item></channel></rss>
